<!DOCTYPE html>
<!--
Copyright (c) 2012 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/extras/importer/linux_perf/parser.html">

<script>
'use strict';

/**
 * @fileoverview Parses rpm events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {

  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux cpufreq trace events.
   * @constructor
   */
  function RpmParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('rpm_resume',
        RpmParser.prototype.rpmResumeEvent.bind(this));
    importer.registerEventHandler('rpm_suspend',
        RpmParser.prototype.rpmSuspendEvent.bind(this));
    importer.registerEventHandler('rpm_idle',
        RpmParser.prototype.rpmIdleEvent.bind(this));
  }

  // Matches the rpm_resume record
  //rpm_resume: 0000:01:00.0 flags-0 cnt-1  dep-0  auto-0 p-0 irq-0 child-0
  const rpmResumeRE = /(.+) flags-(\d+) cnt-(\d+)  dep-(\d+)  auto-(\d+) p-(\d+) irq-(\d+) child-(\d+)/;
  // Matches the rpm_suspend record
  // rpm_suspend: mmc0:0001 flags-d cnt-0  dep-0  auto-1 p-0 irq-0 child-0
  const rpmSuspendRE = /(.+) flags-(\d+) cnt-(\d+)  dep-(\d+)  auto-(\d+) p-(\d+) irq-(\d+) child-(\d+)/;
  // Matches the rpm_idle record
  // rpm_idle: 0000:00:14.0 flags-1 cnt-1  dep-0  auto-1 p-0 irq-0 child-0
  const rpmIdleRE = /(.+) flags-(\d+) cnt-(\d+)  dep-(\d+)  auto-(\d+) p-(\d+) irq-(\d+) child-(\d+)/;


  function pushLastSliceIfNeeded(thread, id, currentTs) {
    if (thread.lastEntryTs !== undefined) {
      const duration = currentTs - thread.lastEntryTs;
      const slice = new tr.model.ThreadSlice(
            '', thread.lastEntryTitle,
            ColorScheme.getColorIdForGeneralPurposeString(id),
            thread.lastEntryTs, thread.lastEntryArgs, duration);
      thread.thread.sliceGroup.pushSlice(slice);
    }
  }

  RpmParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parses rpm_resume events and sets up state in the importer.
     */
    rpmResumeEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      const event = rpmResumeRE.exec(eventBase.details);
      if (!event) return false;

      const dev_name = event[1];
      const dev_flags = event[2];
      const dev_cnt = event[3];
      const dev_dep = event[4];
      const dev_auto = event[5];
      const dev_p = event[6];
      const dev_irq = event[7];
      const dev_child = event[8];

      const thread = this.importer.getOrCreatePseudoThread(
          dev_name);

      pushLastSliceIfNeeded(thread, event[1], ts);

      thread.lastEntryTitle = 'RESUME';
      thread.lastEntryTs = ts;
      thread.lastEntryArgs = {
        'Dev flags': dev_flags,
        'Dev count': dev_cnt,
        'Dev dep': dev_dep,
        'Dev auto': dev_auto,
        'Dev p': dev_p,
        'Dev irq': dev_irq,
        'Dev child': dev_child,
      };
      return true;
    },


    /**
     * Parses rpm_suspend events and sets up state in the importer.
     */
    rpmSuspendEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      const event = rpmSuspendRE.exec(eventBase.details);
      if (!event) return false;

      const dev_name = event[1];
      const dev_flags = event[2];
      const dev_cnt = event[3];
      const dev_dep = event[4];
      const dev_auto = event[5];
      const dev_p = event[6];
      const dev_irq = event[7];
      const dev_child = event[8];

      const thread = this.importer.getOrCreatePseudoThread(
          dev_name);

      pushLastSliceIfNeeded(thread, event[1], ts);

      thread.lastEntryTitle = 'SUSPEND';
      thread.lastEntryTs = ts;
      thread.lastEntryArgs = {
        'Dev flags': dev_flags,
        'Dev count': dev_cnt,
        'Dev dep': dev_dep,
        'Dev auto': dev_auto,
        'Dev p': dev_p,
        'Dev irq': dev_irq,
        'Dev child': dev_child,
      };
      return true;
    },

    /**
     * Parses rpm_idle events and sets up state in the importer.
     */
    rpmIdleEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      const event = rpmIdleRE.exec(eventBase.details);
      if (!event) return false;

      const dev_name = event[1];
      const dev_flags = event[2];
      const dev_cnt = event[3];
      const dev_dep = event[4];
      const dev_auto = event[5];
      const dev_p = event[6];
      const dev_irq = event[7];
      const dev_child = event[8];

      const thread = this.importer.getOrCreatePseudoThread(
          dev_name);

      pushLastSliceIfNeeded(thread, event[1], ts);

      thread.lastEntryTitle = 'IDLE';
      thread.lastEntryTs = ts;
      thread.lastEntryArgs = {
        'Dev flags': dev_flags,
        'Dev count': dev_cnt,
        'Dev dep': dev_dep,
        'Dev auto': dev_auto,
        'Dev p': dev_p,
        'Dev irq': dev_irq,
        'Dev child': dev_child,
      };
      return true;
    },

  };

  Parser.register(RpmParser);

  return {
    RpmParser: RpmParser
  };
});
</script>
