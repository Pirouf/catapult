<!DOCTYPE html>
<!--
Copyright (c) 2012 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/extras/importer/linux_perf/parser.html">

<script>
'use strict';

/**
 * @fileoverview Parses pm qos events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {

  var ColorScheme = tr.b.ColorScheme;
  var Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux cpufreq trace events.
   * @constructor
   */
  function PmQosParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('pm_qos_update_request',
        PmQosParser.prototype.pmQosUpdateRequest.bind(this));
    importer.registerEventHandler('pm_qos_add_request',
        PmQosParser.prototype.pmQosUpdateRequest.bind(this));
    importer.registerEventHandler('pm_qos_remove_request',
        PmQosParser.prototype.pmQosUpdateRequest.bind(this));
    importer.registerEventHandler('pm_qos_update_target',
        PmQosParser.prototype.pmQosUpdateTarget.bind(this));
 
    this.lastRequestClass = undefined

  }

  // Matches the pm_qos_update_request record
  //  pm_qos_update_request: pm_qos_class=CPU_DMA_LATENCY value=20
  const pmQosUpdateRequestRE = /pm_qos_class=(.+) value=(\d+)/;
  // Matches the pm_qos_update_target record
  //  workqueue_execute_end: action=UPDATE_REQ prev_value=2000000000 curr_value=20
  const pmQosUpdateTargetRE = /action=(.+) prev_value=(\d+) curr_value=(\d+)/;

  function pushLastSliceIfNeeded(thread, id, currentTs) {
    if (thread.lastEntryTs !== undefined) {
      const duration = currentTs - thread.lastEntryTs;
      const slice = new tr.model.ThreadSlice(
            '', thread.lastEntryTitle,
            ColorScheme.getColorIdForGeneralPurposeString(id),
            thread.lastEntryTs, thread.lastEntryArgs, duration);
      thread.thread.sliceGroup.pushSlice(slice);
    }
  }

  PmQosParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parses pm_qos_update_request events and sets up state in the importer.
     */
    pmQosUpdateRequest: function(eventName, cpuNumber, pid, ts, eventBase) {
      const event = pmQosUpdateRequestRE.exec(eventBase.details);
      if (!event) return false;

      const pmQosClass = event[1];
      const req_value = event[2];

      const thread = this.importer.getOrCreatePseudoThread(
          pmQosClass);      
      
      pushLastSliceIfNeeded(thread, 'update_request', ts);
      
      thread.lastEntryTitle = 'update_request:' + req_value;
      thread.lastEntryTs = ts;
      thread.lastEntryArgs = {
        'value': req_value
      };

      this.lastRequestClass = pmQosClass;

      return true;
    },

    /**
     * Parses pm_qos_update_target events and sets up state in the importer.
     */
    pmQosUpdateTarget: function(eventName, cpuNumber, pid, ts, eventBase) {
      const event = pmQosUpdateTargetRE.exec(eventBase.details);
      if (!event) return false;

      const action = event[1];
      const prev_value = event[2];
      const curr_value = event[3];      

      const thread = this.importer.getOrCreatePseudoThread(
          this.lastRequestClass);      
      pushLastSliceIfNeeded(thread, action, ts);
      
      thread.lastEntryTitle = action + curr_value;
      thread.lastEntryTs = ts;
      thread.lastEntryArgs = {
        'prev_value': prev_value,
        'curr_value': curr_value
      };

      return true;
    },
  };

  Parser.register(PmQosParser);

  return {
    PmQosParser: PmQosParser
  };
});
</script>
