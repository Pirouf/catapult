<!DOCTYPE html>
<!--
Copyright (c) 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/extras/importer/linux_perf/parser.html">
<link rel="import" href="/tracing/model/alert.html">
<link rel="import" href="/tracing/model/event_info.html">

<script>
'use strict';

/**
 * @fileoverview Parses net qdisc events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses trace events generated by gesture library for touchpad.
   * @constructor
   */
  function QdiscParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('tracing_mark_write:mqprio_qdisc_check',
        QdiscParser.prototype.mqprioCheckEvent.bind(this));
    importer.registerEventHandler('tracing_mark_write:mqprio_stats_check',
        QdiscParser.prototype.qdiscStatsEvent.bind(this));

    importer.registerEventHandler('tracing_mark_write:taprio_qdisc_check',
        QdiscParser.prototype.taprioCheckEvent.bind(this));
    importer.registerEventHandler('tracing_mark_write:taprio_sched_check',
        QdiscParser.prototype.taprioSchedEvent.bind(this));
    importer.registerEventHandler('tracing_mark_write:taprio_stats_check',
        QdiscParser.prototype.qdiscStatsEvent.bind(this));
    importer.registerEventHandler('tracing_mark_write:taprio_drops_check',
        QdiscParser.prototype.qdiscDropsEvent.bind(this));

    importer.registerEventHandler('tracing_mark_write:etf_qdisc_check',
        QdiscParser.prototype.etfCheckEvent.bind(this));
    importer.registerEventHandler('tracing_mark_write:etf_stats_check',
        QdiscParser.prototype.qdiscStatsEvent.bind(this));
    importer.registerEventHandler('tracing_mark_write:etf_drops_check',
        QdiscParser.prototype.qdiscDropsEvent.bind(this));

    importer.registerEventHandler('tracing_mark_write:pfifo_fast_stats_check',
        QdiscParser.prototype.qdiscStatsEvent.bind(this));
    importer.registerEventHandler('tracing_mark_write:ingress_stats_check',
        QdiscParser.prototype.qdiscStatsEvent.bind(this));

    this.model_ = importer.model;
    this.importer_ = importer;

    // A function able to transform timestamps in |clockDomainId| to timestamps
    // in the model clock domain.
    this.toModelTime_ = undefined;
    // A function able to inverse transform timestamps in |clockDomainId| to timestamps
    // in the model clock domain.
    this.FromModelTime_ = undefined;
  }

  const qdiscTaprioRE = new RegExp('clk=(.+) basetime=(\\d+\.?\\d*) flag=0x(\\d) seq=(\\d+) ep=(.+)');
  const qdiscTaprioSchedRE = new RegExp('gate(\\d)=(\\d+\.?\\d*) cmd=(.) mask=(.+) cyc=(\\d+) ep=(.+)');

  const qdiscEtfRE = new RegExp('id=(.+) clk=(.+) qdelay=(\\d+) skipsock=(\\d) qdeadline=(\\d) qoffload=(\\d) ep=(.+)');
  const qdiscMqprioRE = new RegExp('numtc=(\\d) qmap=(.+) qmode=(.+) qshaper=(.+) ep=(.+)');

  const qdiscStatsRE = new RegExp('id=(.+) qpkts=(\\d+) qdrops=(\\d+) ovrlmt=(\\d+) retry=(\\d+) estpps=(.+) ep=(.+)');  
  const qdiscDropsRE = new RegExp('id=(.+) qty=(\\d+) ptp_ts=(\\d+\.?\\d*) ep=(.+)');  

  QdiscParser.prototype = {
    __proto__: Parser.prototype,


    /**
     * Converts |ts| (in microseconds) to a timestamp in the model clock domain
     * (in milliseconds).
     */
    toModelTimeFromUs_(ts) {
      if (!this.toModelTime_) {
        this.toModelTime_ =
            this.model_.clockSyncManager.getModelTimeTransformer(
                tr.model.ClockDomainId.LINUX_FTRACE_GLOBAL);
      }

      return this.toModelTime_(tr.b.Unit.timestampFromUs(ts));
    },

    /**
     * Converts |ts| (in microseconds) From a timestamp in the model clock domain
     * (in milliseconds).
     */
    fromModelTimeFromUs_(ts) {
      if (!this.FromModelTime_) {
        this.FromModelTime_ =
            this.model_.clockSyncManager.getModelTimeTransformer(
                tr.model.ClockDomainId.LINUX_CLOCK_PTP);
      }

      return this.FromModelTime_(tr.b.Unit.timestampFromUs(ts));
    },

    /**
     * For check_clock tracing_mark_write events,
     * mqprio_qdisc_check: numtc=4 qmap=32103333 qmode=dcb qshaper=dcb ep=enp1s0
     */
    mqprioCheckEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const checkEvent = qdiscMqprioRE.exec(eventBase.details);
      if (!checkEvent) return false;

      const adapterName = checkEvent[5];
      const thread = this.model_.getOrCreateNetdev(adapterName).getOrCreateThread("802.1Q");
      thread.name = "802.1Q";
      const category = 'net';
      const title = checkEvent[2];
      const args = {
        'ep': adapterName,
        'mode': checkEvent[3],
        'shaper': checkEvent[4]
      };
      if (!thread.sliceGroup.isTimestampValidForBeginOrEnd(ts)) {
        this.model_.importWarning({
          type: 'parse_error',
          message: 'Timestamps are moving backward.'
        });
        return false;
      }

      if (!thread.sliceGroup.openSliceCount) {
        // Silently ignore unmatched E events.
        thread.sliceGroup.beginSlice(category, title, ts, args);
        return true;
      }
      const slice = thread.sliceGroup.endSlice(ts);
      thread.sliceGroup.beginSlice(category, title, ts, args);
      return true;
    },

    /**
     * For check_clock tracing_mark_write events,
     * taprio_qdisc_check: clk=PTP basetime=1.525795210 flag=0x2 seq=1140582394 ep=enp1s0
     */
    taprioCheckEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const checkEvent = qdiscTaprioRE.exec(eventBase.details);
      if (!checkEvent) return false;

      const adapterName = checkEvent[5];
      const thread = this.model_.getOrCreateNetdev(adapterName).getOrCreateThread("802.1Q");
      thread.name = "802.1Q";
      const category = 'net';
      const title = checkEvent[2];
      const args = {
        'ep': adapterName,
        'clockid': checkEvent[1],
        'basetime': checkEvent[2],
        'flag': checkEvent[3],
        'cycles': checkEvent[4]
      };
      return true;
    },

    /**
     * Opens a new slice in the group's slices.
     */
    beginSchedSlice(sgroup, title, ts, cycletime_ms, args) {
      const sliceConstructorSubTypes = sgroup.sliceConstructorSubTypes;
      const sliceType = sliceConstructorSubTypes.getConstructor(
            'net', 'net_cycle');

      const entrySlice = new sliceType('net', title,
          tr.b.ColorScheme.getColorIdForGeneralPurposeString(title),
          ts,
          args,
          cycletime_ms);

      entrySlice.didNotFinish = true;

      if (!sgroup.openSliceCount) {

        const cycleSlice = new sliceType('net', 'net_cycle',
            tr.b.ColorScheme.getColorIdForGeneralPurposeString('net_cycle'),
            ts,
            args,
            cycletime_ms);
        cycleSlice.subSlices.push(entrySlice);
        cycleSlice.didNotFinish = true;
        sgroup.openPartialSlices_.push(cycleSlice);
      } else {
        sgroup.openPartialSlices_[sgroup.openSliceCount - 1].subSlices.push(entrySlice);
      }
    },


    /**
     * Ends the last begun slice in this group and pushes it onto the slice
     * array.
     */
    endSchedSlice(sgroup, ts) {

      if (!sgroup.openSliceCount)
        throw new Error('endSlice called without an open slice');

      const cycleSlice = sgroup.openPartialSlices_[sgroup.openSliceCount - 1];

      if (ts < cycleSlice.start)
        throw new Error('Slice ' + cycleSlice.title +
                        ' end time is before its start.');

      if (ts < cycleSlice.end) {

        sgroup.openPartialSlices_[sgroup.openSliceCount - 1].didNotFinish = true;
        const lastEntrySlice = sgroup.openPartialSlices_[sgroup.openSliceCount - 1].subSlices.pop();
        lastEntrySlice.duration = ts - lastEntrySlice.start;
        lastEntrySlice.didNotFinish = false;
        sgroup.openPartialSlices_[sgroup.openSliceCount - 1].subSlices.push(lastEntrySlice);

      } else {

        sgroup.openPartialSlices_.splice(sgroup.openSliceCount - 1, 1);

        const lastEntrySlice = cycleSlice.subSlices.pop();
        lastEntrySlice.duration = cycleSlice.end - lastEntrySlice.start;
        lastEntrySlice.didNotFinish = false;
        cycleSlice.subSlices.push(lastEntrySlice);
        /*
        */
        for (i = 0; i < cycleSlice.subSlices.length ; i ++ ) {
          const state = cycleSlice.subSlices[i];
          sgroup.pushSlice(state);
          for (j = state.start + cycleSlice.duration; j < ts ; j += cycleSlice.duration ) {
            const duplicate = sgroup.copySlice(state);
            duplicate.start = j;
            sgroup.pushSlice(duplicate);
          }
        }
      }
    },

    /**
     * Interpret 802.1-2018EST check_clock tracing_mark_write:  events
    taprio_sched_check: gate0=1525853974.795210 cmd=S mask=3ccccccc cyc=1000000 ep=enp1s0
    taprio_sched_check: gate1=1525853974.1295210 cmd=S mask=c210cccc cyc=1000000 ep=enp1s0
     */
    taprioSchedEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const schedEvent = qdiscTaprioSchedRE.exec(eventBase.details);
      if (!schedEvent) return false;

      const TIME = tr.b.UnitScale.TIME;
      const adapterName = schedEvent[6];
      const gateMask = schedEvent[4];
      const gateType = schedEvent[3];
      const gateCyctime_ms = tr.b.convertUnit(parseInt(schedEvent[5]), TIME.NANO_SEC, TIME.MILLI_SEC);

      const gcl_tv_sec = parseInt(schedEvent[2].split('.')[0]);
      const gcl_tv_nsec = parseInt(schedEvent[2].split('.')[1]);
      const gclMsTs = tr.b.convertUnit(gcl_tv_sec, TIME.SEC, TIME.MILLI_SEC) + tr.b.convertUnit(gcl_tv_nsec, TIME.NANO_SEC, TIME.MILLI_SEC);
      const gclNsTs = tr.b.convertUnit(gclMsTs, TIME.MILLI_SEC, TIME.SEC);

      const category = 'net';
      const title = gateType + ":" + gateMask;
      const thread = this.model_.getOrCreateNetdev(adapterName).getOrCreateThread("802.1Q");
      thread.sortIndex = Number.NEGATIVE_INFINITY;
      thread.important = true;
      const args = {
        'ep': adapterName,
        'gcl_index': schedEvent[1],
        'gcl_ts': gclNsTs,
        'gcl_type': gateType,
        'gcl_mask': gateMask,
        'cycletime': schedEvent[5]
      };

      if (!thread.sliceGroup.openSliceCount) {
        // No prior sched.
        this.beginSchedSlice(thread.sliceGroup, title, gclMsTs, gateCyctime_ms, args);
        return true;
      }

      this.endSchedSlice(thread.sliceGroup, gclMsTs);
      this.beginSchedSlice(thread.sliceGroup, title, gclMsTs, gateCyctime_ms, args);
      return true;
    },

    /**
     * For check_clock tracing_mark_write events,
     * etf_qdisc_check: id=1 clk=TAI qdelay=100000 skipsock=0 qdeadline=0 qoffload=1 ep=enp1s0
     */
    etfCheckEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const checkEvent = qdiscEtfRE.exec(eventBase.details);
      if (!checkEvent) return false;

      const adapterName = checkEvent[7];
      const dev = this.model_.getOrCreateNetdev(adapterName);

      return true;
    },

    qdiscStatsSample(parent, counterName, seriesName, ts, s) {
      const value = parseInt(s);
      let noneExitingSerie = true;
      const counter = parent.getOrCreateCounter('', counterName);
      const length = counter.numSeries;
      for (i = 0; i < length ; i++) {
        if (seriesName === counter.series[i].name) {
          counter.series[i].addCounterSample(ts, value);
          noneExitingSerie = false;
          break;
        }
      }

      if (noneExitingSerie) {
        const serie = new tr.model.CounterSeries(seriesName,
        tr.b.ColorScheme.getColorIdForGeneralPurposeString(counter.name));
        serie.addCounterSample(ts, value);
        counter.addSeries(serie);
      }
    },

    /**
     * Any qdisc stats sampling tracing_mark_write event
    taprio_stats_check: id=f qpkts=199507 qdrops=9816 ovrlmt=0 retry=0 estpps=-1 ep=enp1s0
     */
    qdiscStatsEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const statsEvent = qdiscStatsRE.exec(eventBase.details);
      if (!statsEvent) return false;

      const adapterName = statsEvent[7];
      const qdiscName = eventName.split(':')[1];
      const qdiscId = statsEvent[1];
      const counterName = qdiscName.substr(0, qdiscName.search("_stats_check")) + ':'+qdiscId;
      const netdev = this.model_.getOrCreateNetdev(adapterName);
      this.qdiscStatsSample(netdev,counterName, 'queued-packets', ts, statsEvent[2]);
      this.qdiscStatsSample(netdev,counterName, 'retried-packets', ts, statsEvent[5]);
      this.qdiscStatsSample(netdev,counterName, 'dropped-packets', ts, statsEvent[3]);
      this.qdiscStatsSample(netdev,counterName, 'overlimited-packets', ts, statsEvent[4]);
    },

    /**
     *  Any qdisc drop Alerts sampling tracing_mark_write event
    taprio_drops_check: id=f qty=9816 ptp_ts=1525853974.1295210 ep=enp1s0
     */
    qdiscDropsEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const dropsEvent = qdiscDropsRE.exec(eventBase.details);
      if (!dropsEvent) return false;

      const adapterName = dropsEvent[4];
      const qdiscId = dropsEvent[1];
      const qdiscName = eventName.split(':')[1];
      const netdev = this.model_.getOrCreateNetdev(adapterName);
      const AlertName = qdiscName.substr(0, qdiscName.search("_drops_check")) + ':'+qdiscId;
      const args = {
        'ep': adapterName,
        'qdisc': qdiscName.substr(0, qdiscName.search("_drops_check")),
        'id': qdiscId,
        'qty': dropsEvent[2],
        'ts': dropsEvent[3]
      };
      const alert =  new Alert(
          new EventInfo(
               'Issues on '+ adapterName + ' Qdisc ' + AlertName,
               'one or several packets were dropped (i.e. not transmitted)'),
           ts,
           [],
           args);
      this.model_.alerts.push(alert);
    }

  };

  Parser.register(QdiscParser);

  return {
    QdiscParser,
  };
});

</script>
