<!DOCTYPE html>
<!--
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/extras/importer/linux_perf/parser.html">
<link rel="import" href="/tracing/extras/net/ethernet.html">

<script>
'use strict';

/**
 * @fileoverview Parses interrupt events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;
  const vnetIrqHandlerRE = tr.e.net.vnetIrqHandlerRE;
  const ethIrqHandlerRE = tr.e.net.ethIrqHandlerRE;

  /**
   * Parses linux irq trace events.
   * @constructor
   */
  function IrqParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('irq_handler_entry',
        IrqParser.prototype.irqHandlerEntryEvent.bind(this));
    importer.registerEventHandler('irq_handler_exit',
        IrqParser.prototype.irqHandlerExitEvent.bind(this));
    importer.registerEventHandler('softirq_raise',
        IrqParser.prototype.softirqRaiseEvent.bind(this));
    importer.registerEventHandler('softirq_entry',
        IrqParser.prototype.softirqEntryEvent.bind(this));
    importer.registerEventHandler('softirq_exit',
        IrqParser.prototype.softirqExitEvent.bind(this));
    importer.registerEventHandler('ipi_entry',
        IrqParser.prototype.ipiEntryEvent.bind(this));
    importer.registerEventHandler('ipi_exit',
        IrqParser.prototype.ipiExitEvent.bind(this));
    importer.registerEventHandler('preempt_disable',
        IrqParser.prototype.preemptStartEvent.bind(this));
    importer.registerEventHandler('preempt_enable',
        IrqParser.prototype.preemptEndEvent.bind(this));
    importer.registerEventHandler('irq_disable',
        IrqParser.prototype.irqoffStartEvent.bind(this));
    importer.registerEventHandler('irq_enable',
        IrqParser.prototype.irqoffEndEvent.bind(this));
    importer.registerEventHandler('x86_platform_ipi_entry',
        IrqParser.prototype.ipiEntryEvent.bind(this));
    importer.registerEventHandler('x86_platform_ipi_exit',
        IrqParser.prototype.ipiExitEvent.bind(this));
  }

  // Matches the irq_handler_entry record
  const irqHandlerEntryRE = /irq=(\d+) name=(.+)/;

  // Matches the irq_handler_exit record
  const irqHandlerExitRE = /irq=(\d+) ret=(.+)/;

  // Matches the softirq_raise record
  const softirqRE = /vec=(\d+) \[action=(.+)\]/;

  // Matches the ipi_exit_
  const ipiHandlerExitRE = /\((.+)\)/;

  // Matches the preempt_disable/enable records
  const preemptirqRE = /caller=(.+) parent=(.+)/;

  IrqParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parses irq events and sets up state in the mporter.
     */
    irqHandlerEntryEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = irqHandlerEntryRE.exec(eventBase.details);
      if (!event) return false;

      const irq = parseInt(event[1]);
      const name = event[2];

      const thread = this.importer.getOrCreateKernelThread(
          'irqs cpu/' + cpuNumber, "Interrupts", 0 - cpuNumber );
      thread.lastEntryTs = ts;
      thread.irqName = name;

      const irqThreads_ = this.importer.threadsByIrqs[irq +'-'+ thread.irqName.substring(0,7)];
      for (const i in irqThreads_) {

        if ( ( name !==  irqThreads_[i].irqName) &&
             ( name.substring(0,7)  ===  irqThreads_[i].irqName ) &&
             ( irq === irqThreads_[i].irqNum ) ) {
          irqThreads_[i].irqName = name;
          irqThreads_[i].thread.name = 'irq/'+ irq +'-'+ thread.irqName;
        }

        irqThreads_[i].irqEntryTs = ts;
      }

      return true;
    },

    irqHandlerExitEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = irqHandlerExitRE.exec(eventBase.details);
      if (!event) return false;

      const irq = parseInt(event[1]);
      const ret = event[2];
      const thread = this.importer.getOrCreateKernelThread(
          'irqs cpu/' + cpuNumber, "Interrupts", 0 - cpuNumber );

      if (thread.lastEntryTs !== undefined) {
        const duration = ts - thread.lastEntryTs;

        const slice = new tr.model.CpuSlice(
            '',
            'IRQ (' + irq +'-'+ thread.irqName + ')',
            ColorScheme.getColorIdForGeneralPurposeString(event[1]),
            thread.lastEntryTs, { ret ,  'pid' : pid },
            duration);
        thread.thread.sliceGroup.pushSlice(slice);

      }

      if (thread.irqName !== undefined) {
        const irqThreads_ = this.importer.threadsByIrqs[irq +'-'+ thread.irqName.substring(0,7)];
        for (const i in irqThreads_) {

          irqThreads_[i].irqExitTs = ts;
        }

        const vnetHandler = vnetIrqHandlerRE.exec(thread.irqName);
        const ethHandler = ethIrqHandlerRE.exec(thread.irqName);
        if (ethHandler) {
          // irq handler call from physical Ethernet controller eth/enpXsY interface
          const adapterName = ethHandler[1];
          const queuemap = ethHandler[2];
          this.importer.markNetIrq(thread.lastEntryTs, cpuNumber, pid, ts - thread.lastEntryTs, adapterName, parseInt(queuemap), irq +'-'+ thread.irqName.substring(0,7));
        } else  if (vnetHandler) {
          // irq handler call Virtual Ethernet vnet interface
          const adapterName = vnetHandler[1];
          const queuemap = 0;
          this.importer.markNetIrq(thread.lastEntryTs, cpuNumber, pid, ts - thread.lastEntryTs, adapterName+queuemap, parseInt(queuemap), irq +'-'+ thread.irqName.substring(0,7));
        }

        thread.lastEntryTs = undefined;
        thread.irqName = undefined;
      }

      return true;
    },

    softirqRaiseEvent(eventName, cpuNumber, pid, ts, eventBase) {
      return true;
    },

    softirqEntryEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = softirqRE.exec(eventBase.details);
      if (!event) return false;

      const action = event[2];

      const kthread = this.importer.getOrCreateKernelThread(
          'irqs cpu/' + cpuNumber, "Interrupts", 0 - cpuNumber );

      kthread.lastSoftirqEntryTs = ts;

      return true;
    },

    softirqExitEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = softirqRE.exec(eventBase.details);
      if (!event) return false;

      const vec = parseInt(event[1]);
      const action = event[2];

      const kthread = this.importer.getOrCreateKernelThread(
          'irqs cpu/' + cpuNumber, "Interrupts", 0 - cpuNumber );

      const args = {
        'vec' : vec,
        'pid' : pid
      };

      if (kthread.lastSoftirqEntryTs !== undefined) {
        const duration = ts - kthread.lastSoftirqEntryTs;
        const slice = new tr.model.CpuSlice(
            '', action,
            ColorScheme.getColorIdForGeneralPurposeString(event[1]),
            kthread.lastSoftirqEntryTs, args,
            duration);
        kthread.thread.sliceGroup.pushSlice(slice);

        /**/
        if (action === 'NET_TX' )
          this.importer.markNetTxIrq(kthread.lastSoftirqEntryTs, cpuNumber, pid, duration);
        else if (action === 'NET_RX' && pid > 0 )
          this.importer.markNetRxIrq(kthread.lastSoftirqEntryTs, cpuNumber, pid, duration);

      }


      kthread.lastSoftirqEntryTs = undefined;
      return true;
    },
    /**
     * Parses ipi events and sets up state in the mporter.
     */
    ipiEntryEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const thread = this.importer.getOrCreateKernelThread(
          'irqs cpu/' + cpuNumber, "Interrupts", 0);
      thread.lastEntryTs = ts;

      return true;
    },

    ipiExitEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = ipiHandlerExitRE.exec(eventBase.details);
      if (!event) return false;

      const ipiName = event[1];
      const thread = this.importer.getOrCreateKernelThread(
          'irqs cpu/' + cpuNumber, "Interrupts", 0);

      if (thread.lastEntryTs !== undefined) {
        const duration = ts - thread.lastEntryTs;
        const slice = new tr.model.CpuSlice(
            '',
            'IPI (' + ipiName + ')',
            ColorScheme.getColorIdForGeneralPurposeString(ipiName),
            thread.lastEntryTs,
            {},
            duration);
        thread.thread.sliceGroup.pushSlice(slice);
      }
      thread.lastEntryTs = undefined;
      return true;
    },

    /**
     * Parses preempt disable/enable events and sets up state in the importer.
     */
    preemptStartEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = preemptirqRE.exec(eventBase.details);
      if (!event) return false;

      const thread = this.importer.getOrCreatePseudoThread(
          'preempt cpu ' + cpuNumber);
      thread.lastEntryTs = ts;

      thread.preemptStartCaller = event[1];
      thread.preemptStartParent = event[2];
      return true;
    },

    preemptEndEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = preemptirqRE.exec(eventBase.details);
      if (!event) return false;

      const thread = this.importer.getOrCreatePseudoThread(
          'preempt cpu ' + cpuNumber);

      thread.preemptEndCaller = event[1];
      thread.preemptEndParent = event[2];

      if (thread.lastEntryTs !== undefined) {
        const duration = ts - thread.lastEntryTs;
        const slice = new tr.model.ThreadSlice(
            '',
            thread.preemptStartParent + ': ' + thread.preemptStartCaller,
            ColorScheme.getColorIdForGeneralPurposeString(
                thread.preemptEndCaller),
            thread.lastEntryTs, {},
            duration);
        thread.thread.sliceGroup.pushSlice(slice);
      }
      thread.lastEntryTs = undefined;
      return true;
    },

    /**
     * Parses irqoff disable/enable events and sets up state in the importer.
     */
    irqoffStartEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = preemptirqRE.exec(eventBase.details);
      if (!event) return false;

      const thread = this.importer.getOrCreatePseudoThread(
          'irqoff cpu ' + cpuNumber);
      thread.lastEntryTs = ts;

      thread.irqoffStartCaller = event[1];
      thread.irqoffStartParent = event[2];
      return true;
    },

    irqoffEndEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = preemptirqRE.exec(eventBase.details);
      if (!event) return false;

      const thread = this.importer.getOrCreatePseudoThread(
          'irqoff cpu ' + cpuNumber);

      thread.irqoffEndCaller = event[1];
      thread.irqoffEndParent = event[2];

      if (thread.lastEntryTs !== undefined) {
        const duration = ts - thread.lastEntryTs;
        const slice = new tr.model.ThreadSlice(
            '',
            thread.irqoffStartParent + ': ' + thread.irqoffStartCaller,
            ColorScheme.getColorIdForGeneralPurposeString(
                thread.irqoffEndCaller),
            thread.lastEntryTs, {},
            duration);
        thread.thread.sliceGroup.pushSlice(slice);
      }
      thread.lastEntryTs = undefined;
      return true;
    }
  };

  Parser.register(IrqParser);

  return {
    IrqParser,
  };
});
</script>
