<!DOCTYPE html>
<!--
Copyright (c) 2012 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/extras/importer/linux_perf/parser.html">
<link rel="import" href="/tracing/model/counter.html">

<script>
'use strict';

/**
 * @fileoverview Parses Cobalt scheduler events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {

  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses Xenomai  > 3.0.9 (Cobalt) sched trace events.
   * @constructor
   */
  function xnSchedParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('cobalt_switch_context',
        xnSchedParser.prototype.xnSchedSwitchEvent.bind(this));
    importer.registerEventHandler('cobalt_synch_wakeup',
        xnSchedParser.prototype.xnSchedSyncWakeupEvent.bind(this));
    importer.registerEventHandler('cobalt_synch_sleepon',
        xnSchedParser.prototype.xnSchedSyncSleeponEvent.bind(this));
    importer.registerEventHandler('cobalt_lostage_wakeup',
        xnSchedParser.prototype.xnSchedLostageWakeupEvent.bind(this));
    importer.registerEventHandler('cobalt_shadow_gohard',
        xnSchedParser.prototype.xnSchedShadowGohardEvent.bind(this));
    importer.registerEventHandler('cobalt_shadow_hardened',
        xnSchedParser.prototype.xnSchedShadowHardenedEvent.bind(this));
    importer.registerEventHandler('cobalt_shadow_gorelax',
        xnSchedParser.prototype.xnSchedShadowGorelaxEvent.bind(this));
    importer.registerEventHandler('cobalt_shadow_relaxed',
        xnSchedParser.prototype.xnSchedShadowRelaxedEvent.bind(this));
  }

  const TestExports = {};

  // Matches the cobalt_switch_context record format ONLY Xenomai <3.0.9 
  // Example: cobalt_switch_context: prev=ffff8801ffc245c0(ROOT/0) next=ffffc90001b87040(sampling-2562)
  const xnSchedSwitchRELegacy = new RegExp(
      'prev=([0-9a-f]+)(.+) next=([0-9a-f]+)(.+)');
  TestExports.xnSchedSwitchRELegacy = xnSchedSwitchRELegacy;

  // Matches the cobalt_switch_context record Xenomai record format >= 3.0.9 
  // Example: cobalt_switch_context: prev_name=ROOT/0 prev_pid=0 prev_prio=-1 prev_state=0x18008 ==> next_name=sampling-10038 next_pid=10041 next_prio=99
  const xnschedSwitchRE = new RegExp(
      'prev_name=(.+) prev_pid=(\\d+) prev_prio=(\-*\\d+) ' +
      'prev_state=0x([0-9a-f]+) ==> ' +
      'next_name=(.+) next_pid=(\\d+) next_prio=(\-*\\d+)');
  TestExports.xnschedSwitchRE = xnschedSwitchRE;

  // TODO!
  // Matches sched_blocked_reason record
  //const schedBlockedRE = new RegExp('pid=(\\d+) iowait=(\\d) caller=(.+)');
  //TestExports.schedSwitchRE = schedSwitchRE;

  // Matches the cobalt_lostage_wakeup: record
  // success=? is optional not all kernels report it, so don't include
  // it in the capture groups
  // Example: cobalt_lostage_wakeup: pid=2564 comm=display-2562   
  const xnSchedLostageWakeupRE =
      /pid=(\d+) comm=(.+)/;
  TestExports.xnSchedLostageWakeupRE = xnSchedLostageWakeupRE;

  // Matches the cobalt_synch_sleepon: record
  // success=? is optional not all kernels report it, so don't include
  // it in the capture groups
  // Example: cobalt_synch_sleepon: synch=ffffbc44c014e128 thread=ffffbc44c014c040(sampling-852)
  const xnSchedSyncSleeponRE =
      /synch=([0-9a-f]+) thread=([0-9a-f]+)\((.+)\)/;
  TestExports.xnSchedSyncSleeponRE = xnSchedSyncSleeponRE;

  // Matches the cobalt_synch_wakeup: record
  // success=? is optional not all kernels report it, so don't include
  // it in the capture groups
  // Example: cobalt_synch_wakeup: synch=ffffc90001b89128   
  const xnSchedSyncWakeupRE =
      /synch=([0-9a-f]+)/;
  TestExports.xnSchedSyncWakeupRE = xnSchedSyncWakeupRE;

  // Matches the cobalt_shadow_gohard record format ONLY Xenomai < 3.0.9
  // success=? is optional not all kernels report it, so don't include
  // it in the capture groups
  // Example: cobalt_shadow_gohard: thread=ffffc90001b85040(display-2562) pid=2564 state=0x600c0 info=0x0   
  const xnSchedShadowGohardRELegacy =
      /thread=([0-9a-f]+)(.+) pid=(\d+) state=(.+) info=(.+)/;
  TestExports.xnSchedShadowGohardRELegacy = xnSchedShadowGohardRELegacy;

  // Matches the cobalt_shadow_gohard record format ONLY Xenomai >= 3.0.9
  // success=? is optional not all kernels report it, so don't include
  // it in the capture groups
  // Example: cobalt_shadow_gohard: cobalt_shadow_relaxed: state=0x680c0 info=0x0   
  const xnSchedShadowGohardRE =
      /state=(.+) info=(.+)/;
  TestExports.xnSchedShadowGohardRE = xnSchedShadowGohardRE;

  // Matches the cobalt_shadow_hardened: record < 3.0.9
  // success=? is optional not all kernels report it, so don't include
  // it in the capture groups
  // Example: cobalt_shadow_hardened: thread=ffffc90001b85040(display-2562) pid=2564 state=0x60040 info=0x0   
  const xnSchedShadowHardenedRELegacy =
      /thread=([0-9a-f]+)(.+) pid=(\d+) state=(.+) info=(.+)/;
  TestExports.xnSchedShadowHardenedRELegacy = xnSchedShadowHardenedRELegacy;

  // Matches the cobalt_shadow_hardened record format  Xenomai >= 3.0.9
  // success=? is optional not all kernels report it, so don't include
  // it in the capture groups
  // Example: cobalt_shadow_hardened: state=0x60040 info=0x0   
  const xnSchedShadowHardenedRE =
      /state=(.+) info=(.+)/;
  TestExports.xnSchedShadowHardenedRE = xnSchedShadowHardenedRE;

  // Matches the cobalt_shadow_gorelax record format ONLY Xenomai < 3.0.9
  // success=? is optional not all kernels report it, so don't include
  // it in the capture groups
  // Example: cobalt_shadow_gorelax: thread=ffffc90001b85040 reason=undefined   
  const xnSchedShadowGorelaxRELegacy =
      /thread=([0-9a-f]+) reason=(.+)/;
  TestExports.xnSchedShadowGorelaxRELegacy = xnSchedShadowGorelaxRELegacy;

  // Matches the cobalt_shadow_gorelax: record  format Xenomai >= 3.0.9
  // success=? is optional not all kernels report it, so don't include
  // it in the capture groups
  // Example: cobalt_shadow_gorelax: reason=undefined   
  const xnSchedShadowGorelaxRE =
      /reason=(.+)/;
  TestExports.xnSchedShadowGorelaxRE = xnSchedShadowGorelaxRE;

  // Matches the cobalt_shadow_relaxed: record format Xenomai < 3.0.9
  // success=? is optional not all kernels report it, so don't include
  // it in the capture groups
  // Example: cobalt_shadow_relaxed: thread=ffffc90001b85040(display-2562) pid=2564 state=0x600c0 info=0x0   
  const xnSchedShadowRelaxedRELegacy =
      /thread=([0-9a-f]+)(.+) pid=(\d+) state=(.+) info=(.+)/;
  TestExports.xnSchedShadowRelaxedRELegacy = xnSchedShadowRelaxedRELegacy;

  // Matches the cobalt_shadow_relaxed: record  format Xenomai >= 3.0.9
  // success=? is optional not all kernels report it, so don't include
  // it in the capture groups
  // Example: cobalt_shadow_relaxed: state=0x680c0 info=0x0   
  const xnSchedShadowRelaxedRE =
      /state=(.+) info=(.+)/;
  TestExports.xnSchedShadowRelaxedRE = xnSchedShadowRelaxedRE;

  xnSchedParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parses scheduler events and sets up state in the CPUs of the importer.
     * !!! cobalt_switch_context  record format Xenomai >= 3.0.9  !! 
     */
    xnSchedSwitchEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = xnschedSwitchRE.exec(eventBase.details);
      if (!event) return this.xnSchedSwitchEventLegacy(eventName, cpuNumber, pid, ts, eventBase);

      const prevComm = event[1];
      const prevXnid = parseInt(event[2]);
      const prevPrio = parseInt(event[3]);      
      const prevState = event[4];
      const nextComm = event[5];
      const nextXnid = parseInt(event[6]);
      const nextPrio = parseInt(event[7]);

      if (eventBase.tgid !== undefined) {
        const tgid = parseInt(eventBase.tgid);
        const process = this.importer.model_.getOrCreateProcess(tgid);
        if (!process.getThread(pid)) {
          const thread = process.getOrCreateThread(pid);
          thread.name = eventBase.threadName;
        }
      }

      const nextThread = this.importer.threadsByLinuxPid[nextXnid];
      let nextName;
      if (nextThread) {
        nextName = nextThread.userFriendlyName;
      } else {
        nextName = nextComm;
      }


      let prevTask;
      if (prevXnid) {
        prevTask = this.importer.getOrCreateXnThread(prevComm + ':' + prevXnid, "Xenomai/Cobalt tasks", prevXnid, prevXnid );

        if (prevTask.openSlice) {
          prevTask.openSliceDuration = ts - prevTask.openSliceTS;
        }
        prevTask.openSlice = undefined;        
      }

      let nextTask;      
      if (nextXnid && (nextComm !== '(ROOT/'+ cpuNumber +')')) {
        nextTask = this.importer.getOrCreateXnThread(nextComm + ':' + nextXnid, "Xenomai/Cobalt tasks", nextXnid, nextXnid );
  /* */
         nextTask.openSliceTS = ts;
         nextTask.openSlice = nextComm;
      }

      const cpu = this.importer.getOrCreateCpu(cpuNumber);
      cpu.switchActiveThread(
          ts,
          { stateWhenDescheduled: this.importer.formatXnThreadState(prevState) },
          nextXnid,
          nextName,
          {
            comm: nextComm,
            tid: nextXnid,
            prio: nextPrio
          });

      return true;
    },

    xnSchedShadowGohardEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = xnSchedShadowGohardRE.exec(eventBase.details);
      if (!event) xnSchedShadowGohardEventLegacy(eventName, cpuNumber, pid, ts, eventBase);

      const state = event[1];
      const info = event[2];

      //this.importer.markXnidGohardLegacy(ts, pid, comm, pid, pid, state, info);
      this.importer.markXnidGohard(ts, pid, state, info);
      return true;
    },

    xnSchedShadowHardenedEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = xnSchedShadowHardenedRE.exec(eventBase.details);
      if (!event) xnSchedShadowHardenedEventLegacy(eventName, cpuNumber, pid, ts, eventBase);

      const state = event[1];
      const info = event[2];

      //this.importer.markXnidHardenedLegacy(ts, pid, comm, pid, pid, state,info);
      this.importer.markXnidHardened(ts, pid, state,info);
      return true;
    },

    xnSchedShadowGorelaxEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = xnSchedShadowGorelaxRE.exec(eventBase.details);
      if (!event) xnSchedShadowGorelaxEventLegacy(eventName, cpuNumber, pid, ts, eventBase);

      const xnreason = event[2];

      //this.importer.markXnidGorelaxReasonLegacy(ts, pid, pid, xnreason);
      this.importer.markXnidGorelaxReason(ts, pid, xnreason);
      return true;
    },
    
    xnSchedShadowRelaxedEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = xnSchedShadowRelaxedRE.exec(eventBase.details);
      if (!event) xnSchedShadowRelaxedEventLegacy(eventName, cpuNumber, pid, ts, eventBase);

      const state = event[1];
      const info = event[2];

      //this.importer.markXnidRelaxedLegacy(ts, pid, comm, pid, pid, state, info);
      this.importer.markXnidRelaxed(ts, pid);
      return true;
    },

    xnSchedSyncWakeupEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = xnSchedSyncWakeupRE.exec(eventBase.details);
      if (!event) return false;

      const fromPid = pid;
      const xnsync = event[1];
      this.prevHeadSchedState = 'S';

      this.importer.markXnSyncWake(ts, xnsync, cpuNumber, fromPid);
      return true;
    },

    xnSchedLostageWakeupEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = xnSchedLostageWakeupRE.exec(eventBase.details);
      if (!event) return false;

      const fromPid = pid;
      pid = parseInt(event[1]);
      const comm = event[2];
      this.importer.markPidLostage(ts, pid, comm, fromPid);
      return true;
    },

    /**
     * Parses scheduler events and sets up state in the CPUs of the importer.
     * !!! cobalt_switch_context record format ONLY Xenomai <= 3.0.9  !! 
     */
    xnSchedSwitchEventLegacy(eventName, cpuNumber, pid, ts, eventBase) {
      const event = xnSchedSwitchRELegacy.exec(eventBase.details);
      if (!event) return false;

      const prevXnid = event[1];
      const prevComm = event[2];
      const nextXnid = event[3];      
      const nextComm = event[4];

      let prevTask;
      if (prevXnid) {
        prevTask = this.importer.getOrCreatePseudoXnThread(prevComm, "Xenomai/Cobalt tasks", prevXnid);
        prevTask.thread_name = prevComm;

        if (prevTask.openSlice) {
          prevTask.openSliceDuration = ts - prevTask.openSliceTS;
        }
        prevTask.openSlice = undefined;        
      }

      let nextTask;      
      if (nextXnid) {
        nextTask = this.importer.getOrCreatePseudoXnThread(nextComm, "Xenomai/Cobalt tasks", nextXnid);
/* */
        nextTask.thread_name = nextComm;
        nextTask.openSliceTS = ts;
        nextTask.openSlice = nextComm;
      }

      prevTask.lastarg = { stateWhenDescheduled: this.importer.prevRootSchedState, xnStateWhenDescheduled : this.importer.prevHeadSchedState};

      let xpid;
      if (nextComm !== '(ROOT/'+ cpuNumber +')') {
        xpid = nextTask.pid;
      } else {
        xpid = 0; //corresponding to idle state
      }

      const cpu = this.importer.getOrCreateCpu(cpuNumber);
      cpu.switchActiveThread(
          ts,
          prevTask.lastarg,
          xpid,
          nextComm,
          {
            comm: nextComm,
            tid: nextTask.thread.tid,
            xnid: nextXnid,
          });

      return true;
    },

    xnSchedShadowGohardEventLegacy(eventName, cpuNumber, pid, ts, eventBase) {
      const event = xnSchedShadowGohardRELegacy.exec(eventBase.details);
      if (!event) return false;

      const xnid = event[1];
      const comm = event[2];
      const fromPid = parseInt(event[3]);
      const state = event[4];
      const info = event[5];
/*
*/
      if (xnid) {
        const xnthread = this.importer.getOrCreatePseudoXnThread(comm, "Xenomai/Cobalt tasks", xnid);
        //xnthread.lastarg = { stateWhenDescheduled: this.prevRootSchedState, xnStateWhenDescheduled : this.prevHeadSchedState};
        xnthread.thread_name = comm;
        xnthread.openSliceTS = ts;
        xnthread.openSlice = comm;
      }
      this.importer.markXnidGohardLegacy(ts, pid, comm, xnid, fromPid, state, info);

      return true;
    },

    xnSchedShadowHardenedEventLegacy(eventName, cpuNumber, pid, ts, eventBase) {
      const event = xnSchedShadowHardenedRELegacy.exec(eventBase.details);
      if (!event) return false;

      const xnid = event[1];
      const comm = event[2];
      const fromPid = parseInt(event[3]);
      const state = event[4];
      const info = event[5];
      this.prevHeadSchedState = 'M';
/*
*/

      if (xnid) {
        const xnthread = this.importer.getOrCreatePseudoXnThread(comm, "Xenomai/Cobalt tasks", xnid);
        //xnthread.lastarg = { stateWhenDescheduled: this.prevRootSchedState, xnStateWhenDescheduled : this.prevHeadSchedState};
        xnthread.thread_name = comm;
      }
      this.importer.markXnidHardenedLegacy(ts, pid, comm, xnid, fromPid, state,info);
      return true;
    },

    xnSchedShadowGorelaxEventLegacy(eventName, cpuNumber, pid, ts, eventBase) {
      const event = xnSchedShadowGorelaxRELegacy.exec(eventBase.details);
      if (!event) return false;

      const fromPid = pid;
      const xnid = event[1];
      const xnreason = event[2];
  
      this.prevHeadSchedState = 'X';

      this.importer.markXnidGorelaxReasonLegacy(ts, xnid, fromPid, xnreason);
      return true;
    },
    
    xnSchedShadowRelaxedEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = xnSchedShadowRelaxedRE.exec(eventBase.details);
      if (!event) return false;

      const state = event[4];
      const info = event[5];

      this.importer.markXnidRelaxed(ts, pid);
      return true;
    },

    xnSchedShadowRelaxedEventLegacy(eventName, cpuNumber, pid, ts, eventBase) {
      const event = xnSchedShadowRelaxedRELegacy.exec(eventBase.details);
      if (!event) return false;

      const xnid = event[1];
      const comm = event[2];
      const fromPid = parseInt(event[3]);
      const state = event[4];
      const info = event[5];
      this.prevHeadSchedState = 'X';

      if (xnid) {
        const xnthread = this.importer.getOrCreatePseudoXnThread(comm, "Xenomai/Cobalt tasks", xnid);
        //xnthread.lastarg = { stateWhenDescheduled: this.prevRootSchedState, xnStateWhenDescheduled : this.prevHeadSchedState};
        xnthread.thread_name = comm;
        if (xnthread.openSlice) {
          xnthread.openSliceDuration = ts - xnthread.openSliceTS;
        }
        xnthread.openSlice = undefined;        
      }
      this.importer.markXnidRelaxedLegacy(ts, pid, comm, xnid, fromPid, state, info);
      return true;
    },

    xnSchedSyncWakeupEventLegacy(eventName, cpuNumber, pid, ts, eventBase) {
      const event = xnSchedSyncWakeupRE.exec(eventBase.details);
      if (!event) return false;

      const fromPid = pid;
      const xnsync = event[1];
      this.prevHeadSchedState = 'S';

      this.importer.markXnSyncWake(ts, xnsync, cpuNumber, fromPid);
      return true;
    },

    xnSchedSyncSleeponEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = xnSchedSyncSleeponRE.exec(eventBase.details);
      if (!event) return false;

      const fromPid = pid;
      const xnsync = event[1];
      const xnid = event[2];
      const comm = event[3];
      this.prevHeadSchedState = 'S';

      if (xnid) {
        const xnthread = this.importer.getOrCreatePseudoXnThread(comm, "Xenomai/Cobalt tasks", xnid);
        xnthread.thread.sync = xnsync;
        //xnthread.lastarg = { stateWhenDescheduled: this.prevRootSchedState, xnStateWhenDescheduled : this.prevHeadSchedState};
      }
      this.importer.markXnSyncSleep(ts, xnid, xnsync, cpuNumber, fromPid);
      return true;
    },

    xnSchedLostageWakeupEventLegacy(eventName, cpuNumber, pid, ts, eventBase) {
      const event = xnSchedLostageWakeupRE.exec(eventBase.details);
      if (!event) return false;

      const fromPid = pid;
      pid = parseInt(event[1]);
      const comm = event[2];
      this.importer.markPidLostage(ts, pid, comm, fromPid);
      return true;
    },
  };


  Parser.register(xnSchedParser);

  return {
    xnSchedParser,
    _xnSchedParserTestExports: TestExports
  };
});

</script>
