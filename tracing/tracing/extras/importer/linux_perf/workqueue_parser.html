<!DOCTYPE html>
<!--
Copyright (c) 2012 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/extras/importer/linux_perf/parser.html">

<script>
'use strict';

/**
 * @fileoverview Parses workqueue events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux workqueue trace events.
   * @constructor
   */
  function WorkqueueParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('workqueue_execute_start',
        WorkqueueParser.prototype.executeStartEvent.bind(this));
    importer.registerEventHandler('workqueue_execute_end',
        WorkqueueParser.prototype.executeEndEvent.bind(this));
    importer.registerEventHandler('workqueue_queue_work',
        WorkqueueParser.prototype.executeQueueWork.bind(this));
    importer.registerEventHandler('workqueue_activate_work',
        WorkqueueParser.prototype.executeActivateWork.bind(this));
  }

  this.kworkerlookup = {};

  // Matches the workqueue_execute_start record
  //  workqueue_execute_start: work struct c7a8a89c: function MISRWrapper
  const workqueueExecuteStartRE = /work struct (.+): function (\S+)/;

  // Matches the workqueue_execute_start record
  //  workqueue_execute_end: work struct c7a8a89c
  const workqueueExecuteEndRE = /work struct (.+)/;

  const unknownThreadName = '<...>';

  WorkqueueParser.prototype = {
    __proto__: Parser.prototype,

    struct2task(structid) {
      return this.kworkerlookup[structid];
    },

    registerWorkertask(structid, taskname, tid, ts) {
      if (this.kworkerlookup === undefined) this.kworkerlookup = {};
      if (this.struct2task(structid) === undefined)
        this.kworkerlookup[structid] = {'tid': tid, 'ts': ts, 'task': taskname};
    },

    unregisterWorkertask(structid) {
      delete this.kworkerlookup[structid];
    },

    /**
     * Parses workqueue events and sets up state in the importer.
     */
    executeStartEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = workqueueExecuteStartRE.exec(eventBase.details);
      if (!event) return false;

      const kthread = this.importer.getOrCreateKernelThread(
            unknownThreadName, "kworkers" , pid);

      this.registerWorkertask(event[1],event[2],pid,ts);

      kthread.openSliceTS = ts;
      kthread.openSlice = event[2];

      return true;
    },

    executeEndEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = workqueueExecuteEndRE.exec(eventBase.details);
      if (!event) return false;

      const kthread = this.importer.getOrCreateKernelThread(
          unknownThreadName, "kworkers" , pid);

      const wq = this.struct2task(event[1]);
      if (wq) {
        this.unregisterWorkertask(event[1]);
        const slice = new tr.model.CpuSlice('', wq.task,
            ColorScheme.getColorIdForGeneralPurposeString(wq.task),
            wq.ts,
            { 'struct': event[1] },
            ts - wq.ts);
        kthread.thread.sliceGroup.pushSlice(slice);
      }

      kthread.openSlice = undefined;
      return true;

    },

    executeQueueWork(eventName, cpuNumber, pid, ts, eventBase) {
      // TODO: Do something with this event?
      return true;
    },

    executeActivateWork(eventName, cpuNumber, pid, ts, eventBase) {
      // TODO: Do something with this event?
      return true;
    }

  };

  Parser.register(WorkqueueParser);

  return {
    WorkqueueParser,
  };
});
</script>
